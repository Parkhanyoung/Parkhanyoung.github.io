---
title: PyCon - Clean Code, Test, and Refactoring
date: 2021-12-15 00:00:00 +0800
categories: [Better Code, Python]
tags: [clean code, test, TDD, refactoring, python, pycon]
---
# 클린코드, 테스트와 리팩토링
     
**사전 개념**    
* **코드 악취(code smell):** 코드를 읽는 이를 배려하지 않은 코드에서 나타나는 잠재적 문제들을 일컫는 말이다.               
* **보이스카우트 규칙:** 언제나 처음 왔을 때보다 깨끗하게 해놓고 캠프장을 떠날 것. 협업을 한다면 처음 받은 코드보다는 더 깨끗한 코드로 만들어야 한다.    
     
       
### 클린 코드 핵심 가이드     
1. **가드클러즈(Guard Clause):** 올바르지 않은 value를 체크하여 오류를 반환하는 구문을 위쪽에 배치한다. 이 방법을 통해 인덴트를 줄일 수 있다.       
![guardclause](/assets/img/post-img/guardclause.png)
2. **NoneObject 활용:** 객체가 없을 경우 None이 아닌 NoneObject를 반환하도록 하여 해당 객체가 존재하는지 여부를 따로 파악할 필요가 없도록 한다. [ex. 조건에 맞는 user가 없을 경우, user 객체와 같은 인터페이스를 갖는 user NoneObject를 반환함으로써, 별도로 user의 존재 여부를 파악하는 로직을 쓰지 않아도 되게끔 한다.]        
![2](/assets/img/post-img/clean_code2.png)
3. **'not' syntax sugar 이용**   
*syntax sugar를 사용하지 않고, 표준 문법을 사용하는 것을 syntax salt라고 한다. 클린 코드에서는 syntax sugar를 사용할 것을 권장한다.      
![3](/assets/img/post-img/clean_code3.png)
4. **NoneObject 활용2:** 유효성 오류가 발생하는 경우, 즉시 예외를 throw하기보다는 NoneObject를 반환함으로써, 검사를 마지막에 한 번만 진행할 수 있도록 한다.    
![4](/assets/img/post-img/clean_code4.png)
5. **삼항 연산자 이용** if else 키워드 사용 시 짧은 조건은 삼항 연산자를 사용한다.    
![5](/assets/img/post-img/clean_code5.png)
6. 단순한 형태의 if, switch문은 Dict Accessing 형식으로 바꿔준다.    
![6](/assets/img/post-img/clean_code6.png)
7. **작명 방법:** 함수 이름은 snake_case로 지정하고, 행동을 이름의 가장 앞에 명명한다. 명사보다는 동사로써 명확하게 명시해주는 것이 좋다.   
![7](/assets/img/post-img/clean_code7.png)
8. **주석보단 클린 코드:** 주석이 필요할 정도로 복잡한 로직은 별도의 함수로 분리하여, 함수명을 주석 대신 사용한다. 함수를 분리하는 것은 코드의 양을 줄여주고 가독성을 줄여줄 뿐만 아니라, 때로는 다른 클린 코드 패턴을 추가적으로 적용할 수 있게 해준다.      
![8](/assets/img/post-img/clean_code8.png)
      
**그 밖의 규칙**      
* 3줄 이상의 라인이 중복된 코드는 별도의 함수로 분리한다.
* 주석이 없는 코드가 제일 좋은 코드임을 명심하자. [주석 없이 이해될 수 있는 코드가 좋다는 말이지, 그냥 주석을 없애라는 게 아님]
* 클래스와 함수에 너무 많은 기능을 주면 안 된다. 많은 기능이 묶여있다면, 기능 별로 함수, 혹은 클래스를 분리하자.
* 함수의 인자는 4개를 넘으면 안 된다.
* 복잡한 로직은 캡슐화(별도의 함수로 분리)하고 직관적인 이름을 부여하자.
* .py 파일 하나에 두 개 이상의 클래스를 정의하지 말자.


### 테스트와 리팩토링    
**테스트 코드가 없다면?**     
실제 환경에서 동작하는 코드는 생각보다 복잡하다.     
그 복잡한 코드는 내부적으로 서로 연결되어 영향을 주고 받는다.     
코드의 작은 부분을 수정하더라도, 코드 전체에 큰 영향을 주게 된다.       
그렇다고 작은 수정을 할 때마다 일일이 모든 함수를 테스트를 할 수는 없다.      
또한 특정 조건 하에서만 발생하는 버그는 감지하기가 매우 어렵다.      
그렇기 때문에 개발자는 코드 수정, 혹은 기능 추가에 두려움을 가지게 된다.     
       
**테스트 종류**       
* **Unit Test(단위 테스트):** 함수, 메소드의 최소 단위와 각 비즈니스 코드를 체크하는 테스트이다. 파이썬에서는 unittest 모듈을 이용할 수 있다.      
* **Integration Test(통합 테스트):** 여러 함수, 메소드가 모인 코드의 집합을 전체적으로 체크하는 테스트이다. 실제 사용자 기능 위주의 테스트이다.     
* **End-To-End Test(E2E 테스트):** 사용자 관점에서 UI 상에서 실제로 테스트해보는 형식의 테스트이다. 사용자의 소프트, 하드웨어 환경까지 고려하기에 가장 복잡하다. E2E 테스트까지는 하지 않는 경우도 많음.     
      
**테스트 방식**       
1. **White Box Test:** 코드의 내부를 들여다보고 코드를 테스트한다. 보다 세부적인 테스트가 가능하다.       
2. **Black Box Test:** 코드의 내부를 모르는 상태에서 입력 및 출력 값으로 코드를 테스트한다.       
   
![user_service](/assets/img/post-img/clean_code9.png)
*user_service.py는 내부 로직을 알고 진행하는 테스트이므로, White Box Test이고, 각각의 API 테스트는 기대값 충족 여부만을 체크하므로 Black Box Test이다. 이처럼 White Box와 Black Box는 서로 배타적인 관계가 아니며 하나의 테스트 내에서 혼용될 수 있다.      
*Test3은 각각의 API Test(Unit Test)를 엮어 테스트를 진행하였으므로 Integration Test에 속한다.     
     
**올바른 테스트 디자인**    
![testcode_refactor](/assets/img/post-img/clean_code10.png)
테스트 코드는 가장 작은 함수 단위에서부터 통합 단위로 올라가는 Bottom up 방식으로 작업한다.    
세부적인 함수에 대한 테스트를 작성하고, 그 테스트들을 엮어 통합 테스트를 진행하는 형태이다.     
리팩토링은 가장 큰 통합 단위에서 함수 단위로 내려가는 Top-Down 방식으로 작업한다.     
리팩토링은 side effect를 발생시키므로, 가장 큰 단위에서부터 세부적인 함수로 내려가는 형태가 바람직하다.    
        
순수함수가 테스트 작성에 사용하기 적절하다.        
**순수함수:** 함수에 제공된 입력 값에 의해 출력 값이 결정되는 함수이다(하나의 입력 값에 대한 출력 값은 하나뿐이며 외부의 요소에 의해 달라지지 않는다.). 입력 값 외에 상태나 환경에 출력 값이 영향받지 않는다. 순수 함수의 이러한 특징을 참조 투명성(Referential Transparency, RT)라고 한다.          
       
*때로는 외부 서버로부터 값을 받아와 테스트를 진행하는 등 불가피하게 비순수함수가 되는 경우가 있다(ex. request 모듈로 외부로부터 정보를 받아오는 경우). 그런 경우에는 가변적인 외부 값을 mocking하여 테스트를 진행한다(의존성 주입).      
*테스트 함수의 이름은 'test_'로 시작하는 것이 컨벤션이다.       
     

### TDD(Test Driven Development)
테스트 코드를 먼저 작성한 후, 그 테스트 코드를 통과할 수 있는 코드를 작성한다. 그 후 코드의 동작은 차이가 없도록 기능을 유지하면서 코드를 최적화한다. 이 과정에서 테스트 코드에 모두 통과한다는 사실도 유지해야 한다.       
    
*TDD(테스트 주도 개발)는 특정 프레임워크나 도구가 아닌 하나의 개발 방법론을 일컫는 말이다.     
     
**TDD의 필요성**
1. 코드 유지보수에 효과적이다. 기존의 코드를 수정하거나 기능을 추가할 때, 자신이 작성한 코드로 인해 다른 부분에 영향이 가지 않았음을 테스트 코드의 피드백을 통해 명확히 알 수 있다.
2. 작성하는 코드에 대한 이해도가 높아지며 깔끔한 코드를 작성하게 된다. 테스트 코드에 맞는 코드를 작성하기 위해서는 깔끔하고 명확한 코드를 작성할 수밖에 없다.
3. 테스트 코드를 통해 개발자의 의도가 드러나므로, 그 자체로 설명 문서가 된다. 순서대로 이어지는 테스트 코드를 보면 코드 의도를 파악하기가 쉬워진다.
4. 개발자가 직접 코드를 검증하는 과정을 축소할 수 있다.
    
*TDD는 코드 생산성 자체를 높여주는 도구가 아니다. 개발 스펙이 자주 변경되거나 개발 속도가 중요한 개발 환경에는 적합하지 않으며, TravisCI, Jenkins 등을 통한 CI 환경이 구성되어 있어야 비로소 TDD의 장점을 극대화할 수 있다.[다른 자료들을 보니 TDD가 수정 사항에 대한 명확한 피드백을 주므로 불확실성이 높은 작업에 오히려 도움이 된다는 의견도 있다.]        
      
- - -
__공부 자료__     
[pyCon 한성민]우아하게 준비하는 테스트와 리팩토링: https://www.youtube.com/watch?v=S5SY2pkmOy0
[TwentyFiveSeven Velog]TDD를 적용해보자 1편: https://velog.io/@xortm854/TDD%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90-1%ED%8E%B8TDD%EB%9E%80Test-Driven-Development     
[yohanpro blog]테스트 주도 개발 방법론(TDD)과 필요성: https://yohanpro.com/posts/programming/tdd    