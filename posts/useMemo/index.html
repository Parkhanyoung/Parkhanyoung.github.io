<!DOCTYPE html><html lang="ko" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="useMemo, useCallback, useRef" /><meta property="og:locale" content="ko" /><meta name="description" content="useMemo, useCallback, useRef useMemo 주로 복잡한 함수에 의해 산출되는 특정 값을 기억해뒀다가 재활용하기 위해 사용한다. 로또추첨기 함수형 컴포넌트에서 로또 번호를 뽑는 getWinNumbers가 매 렌더링마다 실행이 되었다(함수형 컴포넌트는 리렌더될 때마다 컴포넌트 함수 전체 실행되기 때문). 만약 getWinNumbers가 10초씩 걸리는 로직이었다면, state에 변화가 있을 때마다(리렌더될 때마다) 10초씩 지연됐을 것이다. 이러한 불상사를 막기 위해 useMemo가 존재한다. useMemo로 등록한 값은 캐싱되어, 두번째 인자로 넘긴 배열 속 아이템에 변화가 생기지 않는 한, 캐싱된 값을 재활용한다. useMemo 덕분에 getWinNumbers는 최초 렌더 시와 한번더 버튼을 누를 때만 실행되게 됐다. 이처럼 useMemo는 어떠한 변수값이 복잡한 함수에 의해 산출되는 경우, 그 변수값을 캐싱해서 사용하여 그 함수가 재실행되는 횟수를 최대한 줄이기 위해 활용한다. useCallback 함수형 컴포넌트는 렌더 시마다 전체가 재실행되기 때문에 컴포넌트 내에 선언된 함수가 반복적으로 새로 만들어진다. 만약 함수가 전혀 변하지 않았는데, 그 함수를 다시 생성한다면 그것은 낭비가 될 것이다. 그렇기 떄문에 useCallback을 사용하여 함수를 캐싱한다. useCallback을 사용하면 두번째 인자로 넘겨준 배열의 요소가 변하지 않는 한 캐싱된 함수를 활용한다. 만약 state값에 따라 함수의 내용이 변한다면 그 state값을 두번째 인자의 배열에 넣어주면 필요할 때만 함수를 생성할 수 있다. *특히 자식 컴포넌트에 함수를 넘겨주는 경우에는 useCallback을 필히 사용해야 한다. 왜냐하면 useCallback을 사용하지 않으면, 부모 컴포넌트가 렌더링 될 때마다 자식 컴포넌트에 새롭게 생성한 함수를 넘길 것이며, 자식 컴포넌트는 그것을 props 중 하나가 변한 것으로 인지하여 리렌더할 것이기 때문이다(memo를 사용했다고 하더라도). useMemo vs useRef useMemo와 useRef 모두 특정 값을 기억해두기 위해, 혹은 변수에 담아두기 위해 사용한다는 측면에서 두 가지가 혼동될 수 있다. 이 두 가지가 헷갈릴 때는 각 메소드의 목적을 생각해보면 쉽게 구별할 수 있다. 먼저 useMemo는 앞서 말했듯 복잡한 함수에 의해 산출되는 특정 값을 캐싱해 사용함으로써 성능을 개선하기 위해 사용한다. 그에 반해 useRef는 state로 관리될 필요가 없는 특정 값을 컴포넌트 내에서 활용하거나 DOM을 조작하기 위해 사용한다. Memo는 캐싱하여 성능을 개선하기 위한 목적이고, ref는 특정 값을 다른 곳에서 참조하기 위한 목적이다. useMemo vs useCallback useMemo와 useCallback 모두 성능 개선을 위해 캐싱하기 위해 사용된다는 측면에서 두 가지가 혼동될 수 있다. 이 두 가지가 헷갈릴 때는 각 메소드가 기억하는 대상을 생각해보면 쉽게 구별할 수 있다. useMemo는 함수의 산출값을 기억하는 반면, useCallback은 함수 자체를 기억한다. 함수형 컴포넌트 성능 개선 Tip 함수형 컴포넌트는 state가 바뀔 때마다(리렌더될 때마다) 컴포넌트 함수 전체가 실행된다. 그렇기 때문에 불필요하게 함수가 중복 실행되는 경우가 빈번히 발생한다. 이를 방지하기 위해서는 각 함수에(복잡한 함수면 필수!) console.log(‘함수명’)을 넣어두어 함수들이 정말 필요할 때만 실행되는 것이 맞는지 확인해주는 것이 좋다. 그리고 만약 불필요하게 중복 실행되는 함수가 있다면, 그것은 개선의 여지가 있다는 것이므로 useEffect, useMemo 등을 활용하여 개선한다. 공부 자료 [제로초 유튜브]: useMemo와 useCallback" /><meta property="og:description" content="useMemo, useCallback, useRef useMemo 주로 복잡한 함수에 의해 산출되는 특정 값을 기억해뒀다가 재활용하기 위해 사용한다. 로또추첨기 함수형 컴포넌트에서 로또 번호를 뽑는 getWinNumbers가 매 렌더링마다 실행이 되었다(함수형 컴포넌트는 리렌더될 때마다 컴포넌트 함수 전체 실행되기 때문). 만약 getWinNumbers가 10초씩 걸리는 로직이었다면, state에 변화가 있을 때마다(리렌더될 때마다) 10초씩 지연됐을 것이다. 이러한 불상사를 막기 위해 useMemo가 존재한다. useMemo로 등록한 값은 캐싱되어, 두번째 인자로 넘긴 배열 속 아이템에 변화가 생기지 않는 한, 캐싱된 값을 재활용한다. useMemo 덕분에 getWinNumbers는 최초 렌더 시와 한번더 버튼을 누를 때만 실행되게 됐다. 이처럼 useMemo는 어떠한 변수값이 복잡한 함수에 의해 산출되는 경우, 그 변수값을 캐싱해서 사용하여 그 함수가 재실행되는 횟수를 최대한 줄이기 위해 활용한다. useCallback 함수형 컴포넌트는 렌더 시마다 전체가 재실행되기 때문에 컴포넌트 내에 선언된 함수가 반복적으로 새로 만들어진다. 만약 함수가 전혀 변하지 않았는데, 그 함수를 다시 생성한다면 그것은 낭비가 될 것이다. 그렇기 떄문에 useCallback을 사용하여 함수를 캐싱한다. useCallback을 사용하면 두번째 인자로 넘겨준 배열의 요소가 변하지 않는 한 캐싱된 함수를 활용한다. 만약 state값에 따라 함수의 내용이 변한다면 그 state값을 두번째 인자의 배열에 넣어주면 필요할 때만 함수를 생성할 수 있다. *특히 자식 컴포넌트에 함수를 넘겨주는 경우에는 useCallback을 필히 사용해야 한다. 왜냐하면 useCallback을 사용하지 않으면, 부모 컴포넌트가 렌더링 될 때마다 자식 컴포넌트에 새롭게 생성한 함수를 넘길 것이며, 자식 컴포넌트는 그것을 props 중 하나가 변한 것으로 인지하여 리렌더할 것이기 때문이다(memo를 사용했다고 하더라도). useMemo vs useRef useMemo와 useRef 모두 특정 값을 기억해두기 위해, 혹은 변수에 담아두기 위해 사용한다는 측면에서 두 가지가 혼동될 수 있다. 이 두 가지가 헷갈릴 때는 각 메소드의 목적을 생각해보면 쉽게 구별할 수 있다. 먼저 useMemo는 앞서 말했듯 복잡한 함수에 의해 산출되는 특정 값을 캐싱해 사용함으로써 성능을 개선하기 위해 사용한다. 그에 반해 useRef는 state로 관리될 필요가 없는 특정 값을 컴포넌트 내에서 활용하거나 DOM을 조작하기 위해 사용한다. Memo는 캐싱하여 성능을 개선하기 위한 목적이고, ref는 특정 값을 다른 곳에서 참조하기 위한 목적이다. useMemo vs useCallback useMemo와 useCallback 모두 성능 개선을 위해 캐싱하기 위해 사용된다는 측면에서 두 가지가 혼동될 수 있다. 이 두 가지가 헷갈릴 때는 각 메소드가 기억하는 대상을 생각해보면 쉽게 구별할 수 있다. useMemo는 함수의 산출값을 기억하는 반면, useCallback은 함수 자체를 기억한다. 함수형 컴포넌트 성능 개선 Tip 함수형 컴포넌트는 state가 바뀔 때마다(리렌더될 때마다) 컴포넌트 함수 전체가 실행된다. 그렇기 때문에 불필요하게 함수가 중복 실행되는 경우가 빈번히 발생한다. 이를 방지하기 위해서는 각 함수에(복잡한 함수면 필수!) console.log(‘함수명’)을 넣어두어 함수들이 정말 필요할 때만 실행되는 것이 맞는지 확인해주는 것이 좋다. 그리고 만약 불필요하게 중복 실행되는 함수가 있다면, 그것은 개선의 여지가 있다는 것이므로 useEffect, useMemo 등을 활용하여 개선한다. 공부 자료 [제로초 유튜브]: useMemo와 useCallback" /><link rel="canonical" href="https://parkhanyoung.github.io//posts/useMemo/" /><meta property="og:url" content="https://parkhanyoung.github.io//posts/useMemo/" /><meta property="og:site_name" content="박한영의 개발 블로그" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-24T01:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="useMemo, useCallback, useRef" /><meta name="twitter:site" content="@no_twitter" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"useMemo, useCallback, useRef","dateModified":"2021-12-26T13:02:10+09:00","datePublished":"2021-12-24T01:00:00+09:00","description":"useMemo, useCallback, useRef useMemo 주로 복잡한 함수에 의해 산출되는 특정 값을 기억해뒀다가 재활용하기 위해 사용한다. 로또추첨기 함수형 컴포넌트에서 로또 번호를 뽑는 getWinNumbers가 매 렌더링마다 실행이 되었다(함수형 컴포넌트는 리렌더될 때마다 컴포넌트 함수 전체 실행되기 때문). 만약 getWinNumbers가 10초씩 걸리는 로직이었다면, state에 변화가 있을 때마다(리렌더될 때마다) 10초씩 지연됐을 것이다. 이러한 불상사를 막기 위해 useMemo가 존재한다. useMemo로 등록한 값은 캐싱되어, 두번째 인자로 넘긴 배열 속 아이템에 변화가 생기지 않는 한, 캐싱된 값을 재활용한다. useMemo 덕분에 getWinNumbers는 최초 렌더 시와 한번더 버튼을 누를 때만 실행되게 됐다. 이처럼 useMemo는 어떠한 변수값이 복잡한 함수에 의해 산출되는 경우, 그 변수값을 캐싱해서 사용하여 그 함수가 재실행되는 횟수를 최대한 줄이기 위해 활용한다. useCallback 함수형 컴포넌트는 렌더 시마다 전체가 재실행되기 때문에 컴포넌트 내에 선언된 함수가 반복적으로 새로 만들어진다. 만약 함수가 전혀 변하지 않았는데, 그 함수를 다시 생성한다면 그것은 낭비가 될 것이다. 그렇기 떄문에 useCallback을 사용하여 함수를 캐싱한다. useCallback을 사용하면 두번째 인자로 넘겨준 배열의 요소가 변하지 않는 한 캐싱된 함수를 활용한다. 만약 state값에 따라 함수의 내용이 변한다면 그 state값을 두번째 인자의 배열에 넣어주면 필요할 때만 함수를 생성할 수 있다. *특히 자식 컴포넌트에 함수를 넘겨주는 경우에는 useCallback을 필히 사용해야 한다. 왜냐하면 useCallback을 사용하지 않으면, 부모 컴포넌트가 렌더링 될 때마다 자식 컴포넌트에 새롭게 생성한 함수를 넘길 것이며, 자식 컴포넌트는 그것을 props 중 하나가 변한 것으로 인지하여 리렌더할 것이기 때문이다(memo를 사용했다고 하더라도). useMemo vs useRef useMemo와 useRef 모두 특정 값을 기억해두기 위해, 혹은 변수에 담아두기 위해 사용한다는 측면에서 두 가지가 혼동될 수 있다. 이 두 가지가 헷갈릴 때는 각 메소드의 목적을 생각해보면 쉽게 구별할 수 있다. 먼저 useMemo는 앞서 말했듯 복잡한 함수에 의해 산출되는 특정 값을 캐싱해 사용함으로써 성능을 개선하기 위해 사용한다. 그에 반해 useRef는 state로 관리될 필요가 없는 특정 값을 컴포넌트 내에서 활용하거나 DOM을 조작하기 위해 사용한다. Memo는 캐싱하여 성능을 개선하기 위한 목적이고, ref는 특정 값을 다른 곳에서 참조하기 위한 목적이다. useMemo vs useCallback useMemo와 useCallback 모두 성능 개선을 위해 캐싱하기 위해 사용된다는 측면에서 두 가지가 혼동될 수 있다. 이 두 가지가 헷갈릴 때는 각 메소드가 기억하는 대상을 생각해보면 쉽게 구별할 수 있다. useMemo는 함수의 산출값을 기억하는 반면, useCallback은 함수 자체를 기억한다. 함수형 컴포넌트 성능 개선 Tip 함수형 컴포넌트는 state가 바뀔 때마다(리렌더될 때마다) 컴포넌트 함수 전체가 실행된다. 그렇기 때문에 불필요하게 함수가 중복 실행되는 경우가 빈번히 발생한다. 이를 방지하기 위해서는 각 함수에(복잡한 함수면 필수!) console.log(‘함수명’)을 넣어두어 함수들이 정말 필요할 때만 실행되는 것이 맞는지 확인해주는 것이 좋다. 그리고 만약 불필요하게 중복 실행되는 함수가 있다면, 그것은 개선의 여지가 있다는 것이므로 useEffect, useMemo 등을 활용하여 개선한다. 공부 자료 [제로초 유튜브]: useMemo와 useCallback","url":"https://parkhanyoung.github.io//posts/useMemo/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://parkhanyoung.github.io//posts/useMemo/"},"@context":"https://schema.org"}</script><title>useMemo, useCallback, useRef | 박한영의 개발 블로그</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="박한영의 개발 블로그"><meta name="application-name" content="박한영의 개발 블로그"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/img/github_profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">박한영의 개발 블로그</a></div><div class="site-subtitle font-italic">열심히도 중요하지만 꾸준히가 더 중요하다. 멀리 볼 줄 아는 사람이 되자.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/Parkhanyoung" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/no_twitter" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['phanyoung','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>useMemo, useCallback, useRef</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>useMemo, useCallback, useRef</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/Parkhanyoung">HanyoungPark</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2021-12-24 01:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Fri, Dec 24, 2021, 1:00 AM +0900" >Dec 24</em> </span> <span> Updated <em class="timeago" date="2021-12-26 13:02:10 +0900 " data-toggle="tooltip" data-placement="bottom" title="Sun, Dec 26, 2021, 1:02 PM +0900" >Dec 26</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1171 words"> <em>6 min</em> read</span></div></div></div><div class="post-content"><h1 id="usememo-usecallback-useref">useMemo, useCallback, useRef</h1><h2 id="usememo">useMemo</h2><p>주로 복잡한 함수에 의해 산출되는 특정 값을 기억해뒀다가 재활용하기 위해 사용한다. <br /> 로또추첨기 함수형 컴포넌트에서 로또 번호를 뽑는 getWinNumbers가 매 렌더링마다 실행이 되었다(함수형 컴포넌트는 리렌더될 때마다 컴포넌트 함수 전체 실행되기 때문). <br /> 만약 getWinNumbers가 10초씩 걸리는 로직이었다면, state에 변화가 있을 때마다(리렌더될 때마다) 10초씩 지연됐을 것이다. <br /> 이러한 불상사를 막기 위해 useMemo가 존재한다. <br /> useMemo로 등록한 값은 캐싱되어, 두번째 인자로 넘긴 배열 속 아이템에 변화가 생기지 않는 한, 캐싱된 값을 재활용한다. <br /> useMemo 덕분에 getWinNumbers는 최초 렌더 시와 한번더 버튼을 누를 때만 실행되게 됐다. <br /> 이처럼 useMemo는 어떠한 변수값이 복잡한 함수에 의해 산출되는 경우, 그 변수값을 캐싱해서 사용하여 그 함수가 재실행되는 횟수를 최대한 줄이기 위해 활용한다.</p><h2 id="usecallback">useCallback</h2><p>함수형 컴포넌트는 렌더 시마다 전체가 재실행되기 때문에 컴포넌트 내에 선언된 함수가 반복적으로 새로 만들어진다. <br /> 만약 함수가 전혀 변하지 않았는데, 그 함수를 다시 생성한다면 그것은 낭비가 될 것이다. <br /> 그렇기 떄문에 useCallback을 사용하여 함수를 캐싱한다. <br /> useCallback을 사용하면 두번째 인자로 넘겨준 배열의 요소가 변하지 않는 한 캐싱된 함수를 활용한다. <br /> 만약 state값에 따라 함수의 내용이 변한다면 그 state값을 두번째 인자의 배열에 넣어주면 필요할 때만 함수를 생성할 수 있다. <br /> *특히 자식 컴포넌트에 함수를 넘겨주는 경우에는 useCallback을 필히 사용해야 한다. 왜냐하면 useCallback을 사용하지 않으면, 부모 컴포넌트가 렌더링 될 때마다 자식 컴포넌트에 새롭게 생성한 함수를 넘길 것이며, 자식 컴포넌트는 그것을 props 중 하나가 변한 것으로 인지하여 리렌더할 것이기 때문이다(memo를 사용했다고 하더라도).</p><h2 id="usememo-vs-useref">useMemo vs useRef</h2><p>useMemo와 useRef 모두 특정 값을 기억해두기 위해, 혹은 변수에 담아두기 위해 사용한다는 측면에서 두 가지가 혼동될 수 있다. <br /> 이 두 가지가 헷갈릴 때는 각 메소드의 목적을 생각해보면 쉽게 구별할 수 있다. <br /> 먼저 useMemo는 앞서 말했듯 복잡한 함수에 의해 산출되는 특정 값을 캐싱해 사용함으로써 성능을 개선하기 위해 사용한다. <br /> 그에 반해 useRef는 state로 관리될 필요가 없는 특정 값을 컴포넌트 내에서 활용하거나 DOM을 조작하기 위해 사용한다. <br /> Memo는 캐싱하여 성능을 개선하기 위한 목적이고, ref는 특정 값을 다른 곳에서 참조하기 위한 목적이다.</p><h2 id="usememo-vs-usecallback">useMemo vs useCallback</h2><p>useMemo와 useCallback 모두 성능 개선을 위해 캐싱하기 위해 사용된다는 측면에서 두 가지가 혼동될 수 있다. <br /> 이 두 가지가 헷갈릴 때는 각 메소드가 기억하는 대상을 생각해보면 쉽게 구별할 수 있다. <br /> useMemo는 함수의 산출값을 기억하는 반면, useCallback은 함수 자체를 기억한다.</p><h2 id="함수형-컴포넌트-성능-개선-tip">함수형 컴포넌트 성능 개선 Tip</h2><p>함수형 컴포넌트는 state가 바뀔 때마다(리렌더될 때마다) 컴포넌트 함수 전체가 실행된다. <br /> 그렇기 때문에 불필요하게 함수가 중복 실행되는 경우가 빈번히 발생한다. <br /> 이를 방지하기 위해서는 각 함수에(복잡한 함수면 필수!) console.log(‘함수명’)을 넣어두어 함수들이 정말 필요할 때만 실행되는 것이 맞는지 확인해주는 것이 좋다. <br /> 그리고 만약 불필요하게 중복 실행되는 함수가 있다면, 그것은 개선의 여지가 있다는 것이므로 useEffect, useMemo 등을 활용하여 개선한다.</p><hr /><p><strong>공부 자료</strong> <br /> [제로초 유튜브]: <a href="https://www.youtube.com/watch?v=6H6KncvVc8s&amp;list=PLcqDmjxt30RtqbStQqk-eYMK8N-1SYIFn&amp;index=49">useMemo와 useCallback</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/web/'>Web</a>, <a href='/categories/react/'>React</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/web/" class="post-tag no-text-decoration" >web</a> <a href="/tags/front-end/" class="post-tag no-text-decoration" >front-end</a> <a href="/tags/react/" class="post-tag no-text-decoration" >react</a> <a href="/tags/hooks/" class="post-tag no-text-decoration" >hooks</a> <a href="/tags/usememo/" class="post-tag no-text-decoration" >useMemo</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=useMemo, useCallback, useRef - 박한영의 개발 블로그&url=https://parkhanyoung.github.io//posts/useMemo/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=useMemo, useCallback, useRef - 박한영의 개발 블로그&u=https://parkhanyoung.github.io//posts/useMemo/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=useMemo, useCallback, useRef - 박한영의 개발 블로그&url=https://parkhanyoung.github.io//posts/useMemo/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h4>Recent Update</h4><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/JS%EC%88%9C%ED%99%98%EC%B0%B8%EC%A1%B0/">common js 순환참조</a><li><a href="/posts/%ED%9A%8C%EA%B3%A02021/">2021년을 돌아보며</a><li><a href="/posts/useMemo/">useMemo, useCallback, useRef</a><li><a href="/posts/ReactLifecycle/">React Lifecycle</a><li><a href="/posts/CDM,CWUvsuseEffect/">componentDidMount, componentWillUnmount !== useEffect</a></ul></div><div id="access-tags"><h4 class="text-muted">Trending Tags</h4><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tool/">tool</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/front-end/">front-end</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/pycon/">pycon</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/web/">web</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h4 class="pl-3 pt-2 mb-2">Contents</h4><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/ReactLifecycle/"><div class="card-body"> <em class="timeago small" date="2021-12-21 01:00:00 +0900" >Dec 21</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>React Lifecycle</h3><div class="text-muted small"><p> React 라이프 사이클 라이프 사이클이란 ‘태어나서 죽을 때까지의 과정, 혹은 순서’를 말한다. 리액트의 컴포넌트에게도 라이프 사이클(수명 주기)이 존재한다. 컴포넌트의 라이프 사이클은 ‘페이지에 렌더되기 이전의 준비’로부터 시작되어 ‘페이지에서 사라질 때’ 끝이 난다. 리액트 사용자는 각 컴포넌트의 라이프 사이...</p></div></div></a></div><div class="card"> <a href="/posts/CDM,CWUvsuseEffect/"><div class="card-body"> <em class="timeago small" date="2021-12-22 01:00:00 +0900" >Dec 22</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>componentDidMount, componentWillUnmount !== useEffect</h3><div class="text-muted small"><p> componentDidMount / componentWillUnmount와 useEffect 흔히 클래스형 컴포넌트에서의 componentDidMount와 componentWillUnmount가 함수형 컴포넌트에서의 useEffect에 대응된다고 한다. 하지만 그것은 반은 맞고 반은 틀린 소리이다. 그 이유는 클래스형 컴포넌트는 관리하...</p></div></div></a></div><div class="card"> <a href="/posts/DjangoVSFlask/"><div class="card-body"> <em class="timeago small" date="2021-12-17 01:00:00 +0900" >Dec 17</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PyCon - Django vs Flask</h3><div class="text-muted small"><p> Django vs Flask 웹 프레임워크? 웹: 인터넷 상 연결된 컴퓨터들 간에 정보를 공유할 수 있는 전세계적 정보 공간. 프레임워크: 특정 종류의 소프트웨어를 개발할 때 같은 작업을 반복하지 않을 수 있도록, 필수적으로 거쳐야 하는 과정들을 우아하게 해결해 놓은 도구(클래스, 라이브러리)들의 모음, 혹은 그 구조. 웹을 구현하기 위해서는 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/CDM,CWUvsuseEffect/" class="btn btn-outline-primary" prompt="Older"><p>componentDidMount, componentWillUnmount !== useEffect</p></a> <a href="/posts/%ED%9A%8C%EA%B3%A02021/" class="btn btn-outline-primary" prompt="Newer"><p>2021년을 돌아보며</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://parkhanyoung.github.io//posts/useMemo/'; this.page.identifier = '/posts/useMemo/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://Hanyoung.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/Parkhanyoung">HanyoungPark</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><h4 class="text-muted">Trending Tags</h4><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tool/">tool</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/front-end/">front-end</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/pycon/">pycon</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/web/">web</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
