<!DOCTYPE html><html lang="ko" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="React Lifecycle" /><meta property="og:locale" content="ko" /><meta name="description" content="React 라이프 사이클 라이프 사이클이란 ‘태어나서 죽을 때까지의 과정, 혹은 순서’를 말한다. 리액트의 컴포넌트에게도 라이프 사이클(수명 주기)이 존재한다. 컴포넌트의 라이프 사이클은 ‘페이지에 렌더되기 이전의 준비’로부터 시작되어 ‘페이지에서 사라질 때’ 끝이 난다. 리액트 사용자는 각 컴포넌트의 라이프 사이클 사이사이에 개입하여 특정 동작이 수행되도록 조작할 수 있다. 원하는 결과를 얻기 위해서는 라이프 사이클 중 어느 단계에 개입할지 결정하는 것이 매우 중요하다. 따라서 우리는 컴포넌트의 라이프 사이클을 잘 알 필요가 있다. 컴포넌트 라이프 사이클 메소드 라이프 사이클은 총 9단계로 구성되고 라이프 사이클 메소드는 클래스형 컴포넌트에서만 활용가능하며, 함수형 컴포넌트(hooks 사용)에도 각 메소드에 대응되는 구현 방법이 존재한다. 세부 사항은 다음과 같다. 1. constructor(hooks: useState): 컴포넌트가 만들어질 때 처음으로 호출된다. 이때 초기 state가 정해진다. 2. getDerivedStateFromProps(hooks: 사용법): 컴포넌트가 마운트될 때, 혹은 업데이트될 때 호출된다. props로 받은 값을 state에 동기화한다. 자주 쓰이지는 않는 메소드이다. 3. shouldComponentUpdate(hooks: React.memo(props), useMemo(state)): prop나 state를 변경했을 때, 리렌더링을 할지 말지 결정하는 메소드이다. 반환값은 true, 혹은 false이다. 이 메소드는 성능 최적화만을 위한 것이며, 다른 목적으로 사용했을 시 버그로 이어질 수 있다. 클래스 형에서도 이 메소드보다는 PureComponent를 더 많이 사용한다. 4. render(hooks: 불필요(just return)): 컴포넌트를 렌더한다. 가장 기초적이면서 중요한 메소드이다. 5. getSnapshotBeforeUpdate(hooks: 없음): 렌더링을 통해 만들어진 결과가 브라우저(DOM)에 실제로 반영되기 직전에 호출되며, 변화 적용 이전 props, state 정보를 가져올 수 있다. 또한 이 메소드의 리턴값은 componentDidUpdate의 3번째 파라미터로 넘겨진다. 요소 추가 시에도 스크롤 위치 유지 등에 활용되며, 자주 쓰이지는 않는 메소드이다. 6. componentDidMount(hooks: useEffect + 빈 의존성 배열): 최초 렌더링 이후 호출된다. 컴포넌트가 화면에 표시된 이후에 호출되는 것이다. 업데이트로 인한 리렌더링 시에는 호출되지 않는다. 주로 이 메소드를 통해 setInterval과 같은 비동기 요청을 처리한다. 여기서 구현된 비동기 요청 중 컴포넌트 unmount 직전까지 완료되지 않은 요청은 componentWillUnmount 메소드를 이용하여 정리해주어야 한다. 그렇지 않으면 컴포넌트가 unmount된 이후에도 비동기 요청이 콜스택에 남아 메모리 누수의 원인이 된다. 7. componentDidUpdate(hooks: useEffect): 리렌더링 이후 호출된다. 업데이트 직후이므로, DOM 관련 조작이 가능하다. 8. componentWillUnmount(hooks: useEffect CleanUp 메소드): 컴포넌트를 DOM에서 제거할 때 호출된다. componentDidMount에서 등록한 비동기 이벤트가 있다면 메모리 누수 방지를 위해 여기서 제거해줘야 한다. componentDidMount와 쌍으로 활용되는 경우가 많다. 9. componentDidCatch(hooks: 없음): 컴포넌트 렌더링 도중 에러가 발생했을 경우 호출된다. 오류 발생 시 앱을 멈추지 않고, 오류 UI를 보여주기 위해 사용한다. 공부 자료 [kyun2dat 개인 블로그] 리액트 라이프사이클의 이해 [velopert 개인 블로그] 누구든지 하는 리액트 5편(LifeCycle API)" /><meta property="og:description" content="React 라이프 사이클 라이프 사이클이란 ‘태어나서 죽을 때까지의 과정, 혹은 순서’를 말한다. 리액트의 컴포넌트에게도 라이프 사이클(수명 주기)이 존재한다. 컴포넌트의 라이프 사이클은 ‘페이지에 렌더되기 이전의 준비’로부터 시작되어 ‘페이지에서 사라질 때’ 끝이 난다. 리액트 사용자는 각 컴포넌트의 라이프 사이클 사이사이에 개입하여 특정 동작이 수행되도록 조작할 수 있다. 원하는 결과를 얻기 위해서는 라이프 사이클 중 어느 단계에 개입할지 결정하는 것이 매우 중요하다. 따라서 우리는 컴포넌트의 라이프 사이클을 잘 알 필요가 있다. 컴포넌트 라이프 사이클 메소드 라이프 사이클은 총 9단계로 구성되고 라이프 사이클 메소드는 클래스형 컴포넌트에서만 활용가능하며, 함수형 컴포넌트(hooks 사용)에도 각 메소드에 대응되는 구현 방법이 존재한다. 세부 사항은 다음과 같다. 1. constructor(hooks: useState): 컴포넌트가 만들어질 때 처음으로 호출된다. 이때 초기 state가 정해진다. 2. getDerivedStateFromProps(hooks: 사용법): 컴포넌트가 마운트될 때, 혹은 업데이트될 때 호출된다. props로 받은 값을 state에 동기화한다. 자주 쓰이지는 않는 메소드이다. 3. shouldComponentUpdate(hooks: React.memo(props), useMemo(state)): prop나 state를 변경했을 때, 리렌더링을 할지 말지 결정하는 메소드이다. 반환값은 true, 혹은 false이다. 이 메소드는 성능 최적화만을 위한 것이며, 다른 목적으로 사용했을 시 버그로 이어질 수 있다. 클래스 형에서도 이 메소드보다는 PureComponent를 더 많이 사용한다. 4. render(hooks: 불필요(just return)): 컴포넌트를 렌더한다. 가장 기초적이면서 중요한 메소드이다. 5. getSnapshotBeforeUpdate(hooks: 없음): 렌더링을 통해 만들어진 결과가 브라우저(DOM)에 실제로 반영되기 직전에 호출되며, 변화 적용 이전 props, state 정보를 가져올 수 있다. 또한 이 메소드의 리턴값은 componentDidUpdate의 3번째 파라미터로 넘겨진다. 요소 추가 시에도 스크롤 위치 유지 등에 활용되며, 자주 쓰이지는 않는 메소드이다. 6. componentDidMount(hooks: useEffect + 빈 의존성 배열): 최초 렌더링 이후 호출된다. 컴포넌트가 화면에 표시된 이후에 호출되는 것이다. 업데이트로 인한 리렌더링 시에는 호출되지 않는다. 주로 이 메소드를 통해 setInterval과 같은 비동기 요청을 처리한다. 여기서 구현된 비동기 요청 중 컴포넌트 unmount 직전까지 완료되지 않은 요청은 componentWillUnmount 메소드를 이용하여 정리해주어야 한다. 그렇지 않으면 컴포넌트가 unmount된 이후에도 비동기 요청이 콜스택에 남아 메모리 누수의 원인이 된다. 7. componentDidUpdate(hooks: useEffect): 리렌더링 이후 호출된다. 업데이트 직후이므로, DOM 관련 조작이 가능하다. 8. componentWillUnmount(hooks: useEffect CleanUp 메소드): 컴포넌트를 DOM에서 제거할 때 호출된다. componentDidMount에서 등록한 비동기 이벤트가 있다면 메모리 누수 방지를 위해 여기서 제거해줘야 한다. componentDidMount와 쌍으로 활용되는 경우가 많다. 9. componentDidCatch(hooks: 없음): 컴포넌트 렌더링 도중 에러가 발생했을 경우 호출된다. 오류 발생 시 앱을 멈추지 않고, 오류 UI를 보여주기 위해 사용한다. 공부 자료 [kyun2dat 개인 블로그] 리액트 라이프사이클의 이해 [velopert 개인 블로그] 누구든지 하는 리액트 5편(LifeCycle API)" /><link rel="canonical" href="https://parkhanyoung.github.io//posts/ReactLifecycle/" /><meta property="og:url" content="https://parkhanyoung.github.io//posts/ReactLifecycle/" /><meta property="og:site_name" content="박한영의 개발 블로그" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-21T01:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="React Lifecycle" /><meta name="twitter:site" content="@no_twitter" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"React Lifecycle","dateModified":"2021-12-25T01:26:47+09:00","datePublished":"2021-12-21T01:00:00+09:00","description":"React 라이프 사이클 라이프 사이클이란 ‘태어나서 죽을 때까지의 과정, 혹은 순서’를 말한다. 리액트의 컴포넌트에게도 라이프 사이클(수명 주기)이 존재한다. 컴포넌트의 라이프 사이클은 ‘페이지에 렌더되기 이전의 준비’로부터 시작되어 ‘페이지에서 사라질 때’ 끝이 난다. 리액트 사용자는 각 컴포넌트의 라이프 사이클 사이사이에 개입하여 특정 동작이 수행되도록 조작할 수 있다. 원하는 결과를 얻기 위해서는 라이프 사이클 중 어느 단계에 개입할지 결정하는 것이 매우 중요하다. 따라서 우리는 컴포넌트의 라이프 사이클을 잘 알 필요가 있다. 컴포넌트 라이프 사이클 메소드 라이프 사이클은 총 9단계로 구성되고 라이프 사이클 메소드는 클래스형 컴포넌트에서만 활용가능하며, 함수형 컴포넌트(hooks 사용)에도 각 메소드에 대응되는 구현 방법이 존재한다. 세부 사항은 다음과 같다. 1. constructor(hooks: useState): 컴포넌트가 만들어질 때 처음으로 호출된다. 이때 초기 state가 정해진다. 2. getDerivedStateFromProps(hooks: 사용법): 컴포넌트가 마운트될 때, 혹은 업데이트될 때 호출된다. props로 받은 값을 state에 동기화한다. 자주 쓰이지는 않는 메소드이다. 3. shouldComponentUpdate(hooks: React.memo(props), useMemo(state)): prop나 state를 변경했을 때, 리렌더링을 할지 말지 결정하는 메소드이다. 반환값은 true, 혹은 false이다. 이 메소드는 성능 최적화만을 위한 것이며, 다른 목적으로 사용했을 시 버그로 이어질 수 있다. 클래스 형에서도 이 메소드보다는 PureComponent를 더 많이 사용한다. 4. render(hooks: 불필요(just return)): 컴포넌트를 렌더한다. 가장 기초적이면서 중요한 메소드이다. 5. getSnapshotBeforeUpdate(hooks: 없음): 렌더링을 통해 만들어진 결과가 브라우저(DOM)에 실제로 반영되기 직전에 호출되며, 변화 적용 이전 props, state 정보를 가져올 수 있다. 또한 이 메소드의 리턴값은 componentDidUpdate의 3번째 파라미터로 넘겨진다. 요소 추가 시에도 스크롤 위치 유지 등에 활용되며, 자주 쓰이지는 않는 메소드이다. 6. componentDidMount(hooks: useEffect + 빈 의존성 배열): 최초 렌더링 이후 호출된다. 컴포넌트가 화면에 표시된 이후에 호출되는 것이다. 업데이트로 인한 리렌더링 시에는 호출되지 않는다. 주로 이 메소드를 통해 setInterval과 같은 비동기 요청을 처리한다. 여기서 구현된 비동기 요청 중 컴포넌트 unmount 직전까지 완료되지 않은 요청은 componentWillUnmount 메소드를 이용하여 정리해주어야 한다. 그렇지 않으면 컴포넌트가 unmount된 이후에도 비동기 요청이 콜스택에 남아 메모리 누수의 원인이 된다. 7. componentDidUpdate(hooks: useEffect): 리렌더링 이후 호출된다. 업데이트 직후이므로, DOM 관련 조작이 가능하다. 8. componentWillUnmount(hooks: useEffect CleanUp 메소드): 컴포넌트를 DOM에서 제거할 때 호출된다. componentDidMount에서 등록한 비동기 이벤트가 있다면 메모리 누수 방지를 위해 여기서 제거해줘야 한다. componentDidMount와 쌍으로 활용되는 경우가 많다. 9. componentDidCatch(hooks: 없음): 컴포넌트 렌더링 도중 에러가 발생했을 경우 호출된다. 오류 발생 시 앱을 멈추지 않고, 오류 UI를 보여주기 위해 사용한다. 공부 자료 [kyun2dat 개인 블로그] 리액트 라이프사이클의 이해 [velopert 개인 블로그] 누구든지 하는 리액트 5편(LifeCycle API)","url":"https://parkhanyoung.github.io//posts/ReactLifecycle/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://parkhanyoung.github.io//posts/ReactLifecycle/"},"@context":"https://schema.org"}</script><title>React Lifecycle | 박한영의 개발 블로그</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="박한영의 개발 블로그"><meta name="application-name" content="박한영의 개발 블로그"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/img/github_profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">박한영의 개발 블로그</a></div><div class="site-subtitle font-italic">열심히도 중요하지만 꾸준히가 더 중요하다. 멀리 볼 줄 아는 사람이 되자.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/Parkhanyoung" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/no_twitter" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['phanyoung','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>React Lifecycle</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>React Lifecycle</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/Parkhanyoung">HanyoungPark</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2021-12-21 01:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Tue, Dec 21, 2021, 1:00 AM +0900" >Dec 21</em> </span> <span> Updated <em class="timeago" date="2021-12-25 01:26:47 +0900 " data-toggle="tooltip" data-placement="bottom" title="Sat, Dec 25, 2021, 1:26 AM +0900" >Dec 25</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1071 words"> <em>5 min</em> read</span></div></div></div><div class="post-content"><h1 id="react-라이프-사이클">React 라이프 사이클</h1><p>라이프 사이클이란 ‘태어나서 죽을 때까지의 과정, 혹은 순서’를 말한다. <br /> 리액트의 컴포넌트에게도 라이프 사이클(수명 주기)이 존재한다. <br /> 컴포넌트의 라이프 사이클은 ‘페이지에 렌더되기 이전의 준비’로부터 시작되어 ‘페이지에서 사라질 때’ 끝이 난다. <br /> 리액트 사용자는 각 컴포넌트의 라이프 사이클 사이사이에 개입하여 특정 동작이 수행되도록 조작할 수 있다. <br /> 원하는 결과를 얻기 위해서는 라이프 사이클 중 어느 단계에 개입할지 결정하는 것이 매우 중요하다. <br /> 따라서 우리는 컴포넌트의 라이프 사이클을 잘 알 필요가 있다.</p><h2 id="컴포넌트-라이프-사이클-메소드">컴포넌트 라이프 사이클 메소드</h2><p>라이프 사이클은 총 9단계로 구성되고 라이프 사이클 메소드는 클래스형 컴포넌트에서만 활용가능하며, 함수형 컴포넌트(hooks 사용)에도 각 메소드에 대응되는 구현 방법이 존재한다. <br /> 세부 사항은 다음과 같다.</p><p><img data-proofer-ignore data-src="/assets/img/post-img/reactLifecycle.png" alt="생명주기" /> <br /> <strong>1. constructor(hooks: useState):</strong> 컴포넌트가 만들어질 때 처음으로 호출된다. 이때 초기 state가 정해진다. <br /> <strong>2. getDerivedStateFromProps(hooks: <a href="https://ko.reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops">사용법</a>):</strong> 컴포넌트가 마운트될 때, 혹은 업데이트될 때 호출된다. props로 받은 값을 state에 동기화한다. 자주 쓰이지는 않는 메소드이다. <br /> <strong>3. shouldComponentUpdate(hooks: React.memo(props), useMemo(state)):</strong> prop나 state를 변경했을 때, 리렌더링을 할지 말지 결정하는 메소드이다. 반환값은 true, 혹은 false이다. 이 메소드는 성능 최적화만을 위한 것이며, 다른 목적으로 사용했을 시 버그로 이어질 수 있다. 클래스 형에서도 이 메소드보다는 PureComponent를 더 많이 사용한다. <br /> <strong>4. render(hooks: 불필요(just return)):</strong> 컴포넌트를 렌더한다. 가장 기초적이면서 중요한 메소드이다. <br /> <strong>5. getSnapshotBeforeUpdate(hooks: 없음):</strong> 렌더링을 통해 만들어진 결과가 브라우저(DOM)에 실제로 반영되기 직전에 호출되며, 변화 적용 이전 props, state 정보를 가져올 수 있다. 또한 이 메소드의 리턴값은 componentDidUpdate의 3번째 파라미터로 넘겨진다. 요소 추가 시에도 스크롤 위치 유지 등에 활용되며, 자주 쓰이지는 않는 메소드이다. <br /> <strong>6. componentDidMount(hooks: useEffect + 빈 의존성 배열):</strong> 최초 렌더링 이후 호출된다. 컴포넌트가 화면에 표시된 이후에 호출되는 것이다. 업데이트로 인한 리렌더링 시에는 호출되지 않는다. 주로 이 메소드를 통해 setInterval과 같은 <strong>비동기 요청을 처리</strong>한다. 여기서 구현된 비동기 요청 중 컴포넌트 unmount 직전까지 완료되지 않은 요청은 componentWillUnmount 메소드를 이용하여 정리해주어야 한다. 그렇지 않으면 컴포넌트가 unmount된 이후에도 비동기 요청이 콜스택에 남아 메모리 누수의 원인이 된다. <br /> <strong>7. componentDidUpdate(hooks: useEffect):</strong> 리렌더링 이후 호출된다. 업데이트 직후이므로, DOM 관련 조작이 가능하다. <br /> <strong>8. componentWillUnmount(hooks: useEffect CleanUp 메소드):</strong> 컴포넌트를 DOM에서 제거할 때 호출된다. componentDidMount에서 등록한 비동기 이벤트가 있다면 메모리 누수 방지를 위해 여기서 제거해줘야 한다. componentDidMount와 쌍으로 활용되는 경우가 많다. <br /> <strong>9. componentDidCatch(hooks: 없음):</strong> 컴포넌트 렌더링 도중 에러가 발생했을 경우 호출된다. 오류 발생 시 앱을 멈추지 않고, 오류 UI를 보여주기 위해 사용한다.</p><hr /><p><strong>공부 자료</strong> <br /> [kyun2dat 개인 블로그] <a href="ttps://kyun2da.dev/react/리액트-라이프사이클의-이해">리액트 라이프사이클의 이해</a> <br /> [velopert 개인 블로그] <a href="https://velopert.com/3631">누구든지 하는 리액트 5편(LifeCycle API)</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/web/'>Web</a>, <a href='/categories/react/'>React</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/web/" class="post-tag no-text-decoration" >web</a> <a href="/tags/front-end/" class="post-tag no-text-decoration" >front-end</a> <a href="/tags/react/" class="post-tag no-text-decoration" >react</a> <a href="/tags/lifecycle/" class="post-tag no-text-decoration" >lifecycle</a> <a href="/tags/component/" class="post-tag no-text-decoration" >component</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=React Lifecycle - 박한영의 개발 블로그&url=https://parkhanyoung.github.io//posts/ReactLifecycle/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=React Lifecycle - 박한영의 개발 블로그&u=https://parkhanyoung.github.io//posts/ReactLifecycle/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=React Lifecycle - 박한영의 개발 블로그&url=https://parkhanyoung.github.io//posts/ReactLifecycle/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h4>Recent Update</h4><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/JS%EC%88%9C%ED%99%98%EC%B0%B8%EC%A1%B0/">common js 순환참조</a><li><a href="/posts/%ED%9A%8C%EA%B3%A02021/">2021년을 돌아보며</a><li><a href="/posts/useMemo/">useMemo, useCallback, useRef</a><li><a href="/posts/ReactLifecycle/">React Lifecycle</a><li><a href="/posts/CDM,CWUvsuseEffect/">componentDidMount, componentWillUnmount !== useEffect</a></ul></div><div id="access-tags"><h4 class="text-muted">Trending Tags</h4><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tool/">tool</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/front-end/">front-end</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/pycon/">pycon</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/web/">web</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h4 class="pl-3 pt-2 mb-2">Contents</h4><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CDM,CWUvsuseEffect/"><div class="card-body"> <em class="timeago small" date="2021-12-22 01:00:00 +0900" >Dec 22</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>componentDidMount, componentWillUnmount !== useEffect</h3><div class="text-muted small"><p> componentDidMount / componentWillUnmount와 useEffect 흔히 클래스형 컴포넌트에서의 componentDidMount와 componentWillUnmount가 함수형 컴포넌트에서의 useEffect에 대응된다고 한다. 하지만 그것은 반은 맞고 반은 틀린 소리이다. 그 이유는 클래스형 컴포넌트는 관리하...</p></div></div></a></div><div class="card"> <a href="/posts/useMemo/"><div class="card-body"> <em class="timeago small" date="2021-12-24 01:00:00 +0900" >Dec 24</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>useMemo, useCallback, useRef</h3><div class="text-muted small"><p> useMemo, useCallback, useRef useMemo 주로 복잡한 함수에 의해 산출되는 특정 값을 기억해뒀다가 재활용하기 위해 사용한다. 로또추첨기 함수형 컴포넌트에서 로또 번호를 뽑는 getWinNumbers가 매 렌더링마다 실행이 되었다(함수형 컴포넌트는 리렌더될 때마다 컴포넌트 함수 전체 실행되기 때문). 만약 ge...</p></div></div></a></div><div class="card"> <a href="/posts/DjangoVSFlask/"><div class="card-body"> <em class="timeago small" date="2021-12-17 01:00:00 +0900" >Dec 17</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PyCon - Django vs Flask</h3><div class="text-muted small"><p> Django vs Flask 웹 프레임워크? 웹: 인터넷 상 연결된 컴퓨터들 간에 정보를 공유할 수 있는 전세계적 정보 공간. 프레임워크: 특정 종류의 소프트웨어를 개발할 때 같은 작업을 반복하지 않을 수 있도록, 필수적으로 거쳐야 하는 과정들을 우아하게 해결해 놓은 도구(클래스, 라이브러리)들의 모음, 혹은 그 구조. 웹을 구현하기 위해서는 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Pythonic/" class="btn btn-outline-primary" prompt="Older"><p>PyCon - Pythonic code가 과연 효율적일까?</p></a> <a href="/posts/CDM,CWUvsuseEffect/" class="btn btn-outline-primary" prompt="Newer"><p>componentDidMount, componentWillUnmount !== useEffect</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://parkhanyoung.github.io//posts/ReactLifecycle/'; this.page.identifier = '/posts/ReactLifecycle/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://Hanyoung.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/Parkhanyoung">HanyoungPark</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><h4 class="text-muted">Trending Tags</h4><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tool/">tool</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/front-end/">front-end</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/pycon/">pycon</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/web/">web</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
