<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://parkhanyoung.github.io//</id><title>박한영의 개발 블로그</title><subtitle>다르게 행동하지 않고 다른 결과를 바라지 말자.</subtitle> <updated>2021-12-31T18:37:54+09:00</updated> <author> <name>HanyoungPark</name> <uri>https://parkhanyoung.github.io//</uri> </author><link rel="self" type="application/atom+xml" href="https://parkhanyoung.github.io//feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://parkhanyoung.github.io//"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 HanyoungPark </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>common js 순환참조</title><link href="https://parkhanyoung.github.io//posts/JS%EC%88%9C%ED%99%98%EC%B0%B8%EC%A1%B0/" rel="alternate" type="text/html" title="common js 순환참조" /><published>2021-12-29T01:00:00+09:00</published> <updated>2021-12-31T18:37:32+09:00</updated> <id>https://parkhanyoung.github.io//posts/JS%EC%88%9C%ED%99%98%EC%B0%B8%EC%A1%B0/</id> <content src="https://parkhanyoung.github.io//posts/JS%EC%88%9C%ED%99%98%EC%B0%B8%EC%A1%B0/" /> <author> <name>HanyoungPark</name> </author> <category term="삽질을의미있게" /> <category term="js" /> <summary> 문제 상황 React 강의를 들으며 웹앱을 구현하던 도중, export(import)가 정상적으로 되지 않는 문제가 발생했다. 문법을 올바르게 썼음에도 불구하고 자꾸 빈 객체만 import 되었다. 강의에 나온 코드 그대로 따라쳤으면 좋았으련만, 나는 es6가 아닌 commonjs를 써보겠다고 혼자 다른 코드를 작성하고 있었기 때문에 문제를 쉽사리 해결할 수 없었다. 세부 사항 1. 상황 TicTacToe.jsx에서 CLICK_CELL이라는 상수를 내보내어, Td.jsx라는 동일 경로의 다른 파일에서 그 상수를 받아 오려 한다. 그런데 예상과 달리 빈 객체가 required 되어 CLICK_CELL의 값이 undefined로 나타난다. [해당 상수는 Td.jsx가 아닌 다른 경로에 있는 파일에서는 ... </summary> </entry> <entry><title>2021년을 돌아보며</title><link href="https://parkhanyoung.github.io//posts/%ED%9A%8C%EA%B3%A02021/" rel="alternate" type="text/html" title="2021년을 돌아보며" /><published>2021-12-25T01:00:00+09:00</published> <updated>2021-12-29T23:08:03+09:00</updated> <id>https://parkhanyoung.github.io//posts/%ED%9A%8C%EA%B3%A02021/</id> <content src="https://parkhanyoung.github.io//posts/%ED%9A%8C%EA%B3%A02021/" /> <author> <name>HanyoungPark</name> </author> <category term="회고" /> <category term="2021년" /> <summary> Good Bye 2021 어느덧 크리스마스, 이제는 정들었던 2021년을 보내줄 때가 왔다. 올해는 나에게 여러모로 의미가 깊은 해였다. 전역을 해서 사회로 복귀한 해이고, 어느 때보다 주도적인 태도로 살았던 해이며, 무엇보다 프로그래밍에 대한 흥미를 발견할 수 있었던 해이다. 많은 일들이 있었고 그 일들은 나에게 많은 변화를 가져왔다. 훗날 돌아봤을 때, 올해가 전환점이었다고 생각하는 순간이 분명 있을 것이라고 예상할 만큼, 성격 면에서도, 태도 면에서도, 그리고 진로 면에서도 큰 변화가 있었다. 성인이 된 이후에는, 내가 직접 결정할 수 있는 범위가 넓어지니 시간의 무게, 선택의 무게가 다르게 느껴진다. 단 하루가 이후 십년을 바꿀 수 있으며, 단 하나의 선택이 평생에 영향을 줄 수 있다는 사실을 ... </summary> </entry> <entry><title>useMemo, useCallback, useRef</title><link href="https://parkhanyoung.github.io//posts/useMemo/" rel="alternate" type="text/html" title="useMemo, useCallback, useRef" /><published>2021-12-24T01:00:00+09:00</published> <updated>2021-12-26T13:02:10+09:00</updated> <id>https://parkhanyoung.github.io//posts/useMemo/</id> <content src="https://parkhanyoung.github.io//posts/useMemo/" /> <author> <name>HanyoungPark</name> </author> <category term="Web" /> <category term="React" /> <summary> useMemo, useCallback, useRef useMemo 주로 복잡한 함수에 의해 산출되는 특정 값을 기억해뒀다가 재활용하기 위해 사용한다. 로또추첨기 함수형 컴포넌트에서 로또 번호를 뽑는 getWinNumbers가 매 렌더링마다 실행이 되었다(함수형 컴포넌트는 리렌더될 때마다 컴포넌트 함수 전체 실행되기 때문). 만약 getWinNumbers가 10초씩 걸리는 로직이었다면, state에 변화가 있을 때마다(리렌더될 때마다) 10초씩 지연됐을 것이다. 이러한 불상사를 막기 위해 useMemo가 존재한다. useMemo로 등록한 값은 캐싱되어, 두번째 인자로 넘긴 배열 속 아이템에 변화가 생기지 않는 한, 캐싱된 값을 재활용한다. useMemo 덕분에 ... </summary> </entry> <entry><title>componentDidMount, componentWillUnmount !== useEffect</title><link href="https://parkhanyoung.github.io//posts/CDM,CWUvsuseEffect/" rel="alternate" type="text/html" title="componentDidMount, componentWillUnmount !== useEffect" /><published>2021-12-22T01:00:00+09:00</published> <updated>2021-12-25T01:26:47+09:00</updated> <id>https://parkhanyoung.github.io//posts/CDM,CWUvsuseEffect/</id> <content src="https://parkhanyoung.github.io//posts/CDM,CWUvsuseEffect/" /> <author> <name>HanyoungPark</name> </author> <category term="Web" /> <category term="React" /> <summary> componentDidMount / componentWillUnmount와 useEffect 흔히 클래스형 컴포넌트에서의 componentDidMount와 componentWillUnmount가 함수형 컴포넌트에서의 useEffect에 대응된다고 한다. 하지만 그것은 반은 맞고 반은 틀린 소리이다. 그 이유는 클래스형 컴포넌트는 관리하는 state 값이 변화할 경우, render 메소드만 실행되지만, 함수형 컴포넌트는 기존의 컴포넌트가 언마운트되고 함수 전체가 다시 실행되어 다르게 동작하기 때문이다. 예시를 들어보겠다. const React = require('react'); const { useState, useEffect, useRef } = React; const [... </summary> </entry> <entry><title>React Lifecycle</title><link href="https://parkhanyoung.github.io//posts/ReactLifecycle/" rel="alternate" type="text/html" title="React Lifecycle" /><published>2021-12-21T01:00:00+09:00</published> <updated>2021-12-25T01:26:47+09:00</updated> <id>https://parkhanyoung.github.io//posts/ReactLifecycle/</id> <content src="https://parkhanyoung.github.io//posts/ReactLifecycle/" /> <author> <name>HanyoungPark</name> </author> <category term="Web" /> <category term="React" /> <summary> React 라이프 사이클 라이프 사이클이란 ‘태어나서 죽을 때까지의 과정, 혹은 순서’를 말한다. 리액트의 컴포넌트에게도 라이프 사이클(수명 주기)이 존재한다. 컴포넌트의 라이프 사이클은 ‘페이지에 렌더되기 이전의 준비’로부터 시작되어 ‘페이지에서 사라질 때’ 끝이 난다. 리액트 사용자는 각 컴포넌트의 라이프 사이클 사이사이에 개입하여 특정 동작이 수행되도록 조작할 수 있다. 원하는 결과를 얻기 위해서는 라이프 사이클 중 어느 단계에 개입할지 결정하는 것이 매우 중요하다. 따라서 우리는 컴포넌트의 라이프 사이클을 잘 알 필요가 있다. 컴포넌트 라이프 사이클 메소드 라이프 사이클은 총 9단계로 구성되고 라이프 사이클 메소드는 클래스형 컴포넌... </summary> </entry> </feed>
